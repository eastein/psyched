#!/usr/bin/env python
'''
Psyched is a scheduling and task management application.

Copyright 2007 Eric Stein
License: GPL2/GPL3, at your option.
'''

import gtk
import gobject
import time
import datetime
import threading
import psyched_validate as pv
import psyched_backend as pb

(
	COLUMN_TIME,
	COLUMN_DESC,
	COLUMN_EDITABLE
) = range(3)
(
	SCOLUMN_ID,
	SCOLUMN_TEXT,
	SCOLUMN_TS_,
	SCOLUMN_DURATION_,
	SCOLUMN_COMPLETE,
	SCOLUMN_TASK,
	SCOLUMN_EDITABLE
) = range(7)
(
	TCOLUMN_ID,
	TCOLUMN_TEXT,
	TCOLUMN_DUE_,
	TCOLUMN_COMPLETE,
	TCOLUMN_EDITABLE
) = range(5)

cont = True

class Psyched(gtk.Window) :
	def __init__(self, parent=None) :
		self.day = datetime.timedelta(days=1)
		self.backend = pb.PsychedBackend()

		gtk.Window.__init__(self)
		self.connect('destroy', self.__die__)

		self.set_title("Psyched")
		self.set_default_size(450,600)
		self.set_border_width(0)

		schedule_ = gtk.VBox(homogeneous=False, spacing=4)
		schedule_.set_border_width(5)
		tasks_ = gtk.VBox(homogeneous=False, spacing=4)
		tasks_.set_border_width(5)

		schedule = gtk.ScrolledWindow()
		schedule.set_policy(gtk.POLICY_NEVER, gtk.POLICY_ALWAYS)
		tasks = gtk.ScrolledWindow()
		tasks.set_policy(gtk.POLICY_NEVER, gtk.POLICY_ALWAYS)

		schedule.add_with_viewport(schedule_)
		tasks.add_with_viewport(tasks_)

		slabel = gtk.Label("Schedule")
		tlabel = gtk.Label("Tasks")

		tabset = gtk.Notebook()
		tabset.append_page(schedule, slabel)
		tabset.append_page(tasks, tlabel)
		self.add(tabset)
	
		self.populate_tabs(schedule_, tasks_, 7)

		self.timer = BackgroundTimer()
		self.timer.start()

		self.win = None
		self.show_all()

		print self.input_dialog("Test", [(gtk.Calendar, "Date", None), (gtk.Entry, "Some Text", pv.check_time)])

	def __die__(self, parent=None) :
		global cont
		cont = False

	def populate_tabs(self, sched, tasks, days) :
		scols = [(SCOLUMN_COMPLETE, "Attended"), (SCOLUMN_TS_, "Time"), (SCOLUMN_DURATION_, "Length"), (SCOLUMN_TEXT, "Description")]
		tcols = [(TCOLUMN_COMPLETE, "Done"), (TCOLUMN_DUE_, "Time"), (TCOLUMN_TEXT, "Description")]

		self.add_items_to_vbox(sched, self.iterate_get(days, lambda t, d: self.create_list_sched(self.backend.fetch_schedule(t, d)), (scols, SCOLUMN_EDITABLE)))
		self.add_items_to_vbox(tasks, self.iterate_get(days, lambda t, d: self.create_list_task(self.backend.fetch_dated_tasks(t, d)), (tcols, TCOLUMN_EDITABLE)))

	def iterate_get(self, days, fetch, colargs) :
		(l, e) = colargs
		today = datetime.date.today()
		r = []
		for i in range(days) :
			day = today + self.day * i
			lset = gtk.HBox()
			lset.pack_start(gtk.Label(day.isoformat()))
			lset.pack_start(gtk.Button(stock=gtk.STOCK_ADD))
			r.append(lset)
			(t, d) = self.getperiod(today + self.day * i)

			dl = fetch(t, d)
			tv = self.create_tree(dl)
			self.add_columns(tv, l, e)
			r.append(tv)
		return r

	def getperiod(self, d) :
		f1 = int(time.mktime(d.timetuple()))
		f2 = int(time.mktime((d + self.day).timetuple()))
		return (f1, f2 - f1)

	def getter(self, type) :
		if type == gtk.Calendar :
			return gtk.Calendar.get_date
		if type == gtk.Entry :
			return gtk.Entry.get_text

	def input_dialog(self, title, fields) :
		d = gtk.Dialog(title, self, gtk.DIALOG_MODAL,
			(gtk.STOCK_OK, gtk.RESPONSE_OK,
			gtk.STOCK_CANCEL, gtk.RESPONSE_CANCEL))

		# create table for storing fields
		table = gtk.Table(len(fields), 2)
		table.set_row_spacings(4)
		table.set_col_spacings(4)

		# create status label
		d.vbox.add(table)
		status = gtk.Label("\nOK")
		d.vbox.add(status)

		row = 0
		gui = []
		# for each field, create label and appropriate gtk element
		for field in fields :
			(type, name, valid) = field
			label = gtk.Label(name)
			table.attach(label, 0, 1, row, row + 1)

			f = type()

			table.attach(f, 1, 2, row, row + 1)
			gui.append((f, type, name, valid))

			row += 1

		d.show_all()

		# until valid, loop
		comp = False
		while not comp :
			comp = True
			response = d.run()
			r = None
			# if ok pressed, get and validate input
			if response == gtk.RESPONSE_OK :
				r = {}
				for g in gui :
					(element, type, name, valid) = g
					# get gui element's value
					value = self.getter(type)(element)
					if valid != None :
						# if there is validation to run, check it and alert
						# the user if there is an issue
						v = valid(value)
						if not v :
							comp = False
							status.set_text("\n" + name + " is improperly formatted.")
					# store value
					r[name] = value

		# destroy dialog and return
		d.destroy()
		return r

	def dialog(self, s) :
		dialog = gtk.MessageDialog(self,
			gtk.DIALOG_MODAL | gtk.DIALOG_DESTROY_WITH_PARENT,
			gtk.MESSAGE_ERROR, gtk.BUTTONS_OK, s)
		dialog.run()
		dialog.destroy()

	def add_items_to_vbox(self, vb, list) :
		for item in list :
			vb.pack_start(item, expand=False)

	def clear_vbox(self, vb) :
		vb.forall(vb.remove)

	def create_tree(self, list) :
		treeview = gtk.TreeView(list)
		treeview.set_rules_hint(True)
		treeview.get_selection().set_mode(gtk.SELECTION_SINGLE)

		return treeview

	def create_list_task(self, list) :
		model = gtk.ListStore(
			gobject.TYPE_INT,	#id
			gobject.TYPE_STRING,	#text
			gobject.TYPE_STRING,	#text version of due
			gobject.TYPE_BOOLEAN,	#complete
			gobject.TYPE_BOOLEAN	#editable
		)

		model.set_sort_column_id(TCOLUMN_DUE_, gtk.SORT_ASCENDING)

		for item in list :
			iter = model.append()
			(id, text, due, complete) = item
			model.set(iter,
				TCOLUMN_ID, id,
				TCOLUMN_TEXT, text,
				TCOLUMN_DUE_, time.strftime('%H:%M', time.localtime(due)),
				TCOLUMN_COMPLETE, complete,
				TCOLUMN_EDITABLE, True
			)

		return model

	def sched_db2li(self, t) :
		(id, text, ts, duration, complete, task) = item

		ts_ = time.strftime('%H:%M', time.localtime(ts))
		duration_ = pb.sec2dur(duration)
		complete = bool(complete)
		editable = True

		return (id, text, ts_, duration_, complete, task, editable)

	def create_list_sched(self, list) :
		model = gtk.ListStore(
			gobject.TYPE_INT,	#id
			gobject.TYPE_STRING,	#text
			gobject.TYPE_STRING,	#text version of time
			gobject.TYPE_STRING,	#text version of duration
			gobject.TYPE_BOOLEAN,	#complete
			gobject.TYPE_INT,	#task
			gobject.TYPE_BOOLEAN	#editable
		)

		model.set_sort_column_id(SCOLUMN_TS_, gtk.SORT_ASCENDING)

		for item in list :
			iter = model.append()
			(id, text, ts, duration, complete, task) = item
			model.set(iter,
				SCOLUMN_ID, id,
				SCOLUMN_TEXT, text,
				SCOLUMN_TS_, time.strftime('%H:%M', time.localtime(ts)),
				SCOLUMN_DURATION_, pb.sec2dur(duration),
				SCOLUMN_COMPLETE, bool(complete),
				SCOLUMN_TASK, task,
				SCOLUMN_EDITABLE, True
			)

		return model

	def add_columns(self, treeview, colset, col_e):
		model = treeview.get_model()

		for col in colset :
			(cid, ctext) = col
			renderer = None
			isbool = model.get_column_type(cid) == gobject.TYPE_BOOLEAN
			if isbool :
				# create a toggle for boolean types
				renderer = gtk.CellRendererToggle()
				renderer.connect("toggled", self.on_item_toggled, model)
			else :
				# otherwise input is text, create text entry
				renderer = gtk.CellRendererText()
				renderer.connect("edited", self.on_cell_edited, model)

			# align elements to the left
			renderer.set_property("xalign", 0.0)
			renderer.set_data("column", cid)

			# create column
			if isbool :
				column = gtk.TreeViewColumn(ctext, renderer, active=cid, activatable=col_e)
			else :
				column = gtk.TreeViewColumn(ctext, renderer, text=cid, editable=col_e)
			treeview.append_column(column)

	def on_item_toggled(self, cell, path_string, model) :
		column = cell.get_data('column')
		iter = model.get_iter_from_string(path_string)
		toggle_item = model.get_value(iter, column)

		toggle_item = not toggle_item

		model.set(iter, column, toggle_item)

	def on_cell_edited(self, cell, path_string, new_text, model) :
		iter = model.get_iter_from_string(path_string)
		path = model.get_path(iter)[0]
		column = cell.get_data("column")

		update = None
		if column == COLUMN_DESC :
			update = new_text
			# call into storage backend here
		elif column == COLUMN_TIME :
			if (pv.check_time(new_text)) :
				update = new_text
				# call into storage backend here
		if update == None :
			self.dialog('Incorrect formatting.')
		else :
			model.set(iter, column, update)


class BackgroundTimer(threading.Thread) :
	def __init__(self) :
		# initialize empty callback list
		self.callbacks = {'d':[], 'h':[], 'm':[], 's':[]}
		# start thread
		threading.Thread.__init__(self)

	def run(self) :
		global cont

		# initial time info
		self.gmt = time.gmtime()
		self.day = time.strftime('%j', self.gmt)
		self.hour = time.strftime('%H', self.gmt)
		self.min = time.strftime('%M', self.gmt)
		self.sec = time.strftime('%S', self.gmt)

		while cont :
			# current time info
			gmt = time.gmtime()
			_day = time.strftime('%j', gmt)
			_hour = time.strftime('%H', gmt)
			_min = time.strftime('%M', gmt)
			_sec = time.strftime('%S', gmt)

			# for each interval, run the callbacks if interval
			# has passed
			if self.day != _day :
				for c in self.callbacks['d'] :
					c()
			if self.hour != _hour :
				for c in self.callbacks['h'] :
					c()
			if self.min != _min :
				for c in self.callbacks['m'] :
					c()
			if self.sec != _sec :
				for c in self.callbacks['s'] :
					c()

			# copy current time to old time for use in next cycle
			self.day = _day
			self.hour = _hour
			self.min = _min
			self.sec = _sec

			time.sleep(0.5)

	def add_callback(self, period, callback) :
		self.callbacks[period].append(callback)

def gtkm() :
	global cont
	while cont :
		while gtk.events_pending() :
			gtk.main_iteration()
		time.sleep(0.02)

if __name__ == '__main__':
	psyched = Psyched()
	try:
		gtkm()
	except KeyboardInterrupt:
		cont = False
