#!/usr/bin/env python
'''
Psyched is a scheduling and task management application.

Copyright 2007 Eric Stein
License: GPL2/GPL3, at your option.
'''

import gtk
import gobject
import random
import time
import datetime
import threading
import psyched_validate as pv
import psyched_backend as pb

(
	COLUMN_TIME,
	COLUMN_DESC,
	COLUMN_EDITABLE
) = range(3)
(
	SCOLUMN_ID,
	SCOLUMN_TEXT,
	SCOLUMN_TS_,
	SCOLUMN_DURATION_,
	SCOLUMN_COMPLETE,
	SCOLUMN_TASK,
	SCOLUMN_EDITABLE
) = range(7)
(
	TCOLUMN_ID,
	TCOLUMN_TEXT,
	TCOLUMN_DUE_,
	TCOLUMN_COMPLETE,
	TCOLUMN_EDITABLE
) = range(5)

cont = True

class Psyched(gtk.Window) :
	def __init__(self, parent=None) :
		self.day = datetime.timedelta(days=1)
		self.backend = pb.PsychedBackend()

		gtk.Window.__init__(self)
		self.connect('destroy', self.__die__)

		self.set_title("Psyched")
		self.set_default_size(450,600)
		self.set_border_width(0)

		schedule_ = gtk.VBox(homogeneous=False, spacing=4)
		schedule_.set_border_width(5)
		tasks_ = gtk.VBox(homogeneous=False, spacing=4)
		tasks_.set_border_width(5)

		schedule = gtk.ScrolledWindow()
		schedule.set_policy(gtk.POLICY_NEVER, gtk.POLICY_ALWAYS)
		tasks = gtk.ScrolledWindow()
		tasks.set_policy(gtk.POLICY_NEVER, gtk.POLICY_ALWAYS)

		schedule.add_with_viewport(schedule_)
		tasks.add_with_viewport(tasks_)

		slabel = gtk.Label("Schedule")
		tlabel = gtk.Label("Tasks")

		tabset = gtk.Notebook()
		tabset.append_page(schedule, slabel)
		tabset.append_page(tasks, tlabel)
		self.add(tabset)
		
		scols = [(SCOLUMN_COMPLETE, "Attended"), (SCOLUMN_TS_, "Time"), (SCOLUMN_DURATION_, "Length"), (SCOLUMN_TEXT, "Description")]
		self.add_items_to_vbox(schedule_, self.iterate_get(3, lambda t, d: self.create_list_sched(self.backend.fetch_schedule(t, d)), (scols, SCOLUMN_EDITABLE)))

		tcols = [(TCOLUMN_COMPLETE, "Done"), (TCOLUMN_DUE_, "Time"), (TCOLUMN_TEXT, "Description")]
		self.add_items_to_vbox(tasks_, self.iterate_get(3, lambda t, d: self.create_list_task(self.backend.fetch_dated_tasks(t, d)), (tcols, TCOLUMN_EDITABLE)))

		self.timer = BackgroundTimer()
		self.timer.start()

		self.win = None
		self.show_all()

	def __die__(self, parent=None) :
		global cont
		cont = False

	def iterate_get(self, days, fetch, colargs) :
		(l, e) = colargs
		today = datetime.date.today()
		r = []
		for i in range(days) :
			day = today + self.day * i
			lset = gtk.HBox()
			lset.pack_start(gtk.Label(day.isoformat()))
			lset.pack_start(gtk.Button(stock=gtk.STOCK_ADD))
			r.append(lset)
			(t, d) = self.getperiod(today + self.day * i)

			dl = fetch(t, d)
			tv = self.create_tree(dl)
			self.add_columns(tv, l, e)
			r.append(tv)
		return r

	def getperiod(self, d) :
		f1 = int(time.mktime(d.timetuple()))
		f2 = int(time.mktime((d + self.day).timetuple()))
		return (f1, f2 - f1)

	def input_dialog(self, title, fields) :
		d = gtk.Dialog(title, self, 0,
			(gtk.STOCK_OK, gtk.RESPONSE_OK,
			gtk.STOCK_CANCEL, gtk.RESPONSE_CANCEL))

		table = gtk.Table(len(fields), 2)
		table.set_row_spacings(4)
		table.set_col_spacings(4)

		d.vbox.add(table)

		row = 0
		gui = []
		for field in fields :
			(type, name) = field
			label = gtk.Label(name)
			table.attach(label, 0, 1, row, row + 1)

			f = type()

			table.attach(f, 1, 2, row, row + 1)
			gui.append((f, type, name))

			row += 1

		d.show_all()
		response = d.run()

		r = None
		if response == gtk.RESPONSE_OK :
			r = {}
			for g in gui :
				(element, type, name) = g
				if type == gtk.Calendar :
					r[name] = element.get_date()
				if type == gtk.Entry :
					r[name] = element.get_text()

		d.destroy()
		return r

	def dialog(self, s) :
		dialog = gtk.MessageDialog(self,
			gtk.DIALOG_MODAL | gtk.DIALOG_DESTROY_WITH_PARENT,
			gtk.MESSAGE_ERROR, gtk.BUTTONS_OK, s)
		dialog.run()
		dialog.destroy()

	def add_items_to_vbox(self, vb, list) :
		for item in list :
			vb.pack_start(item, expand=False)

	def clear_vbox(self, vb) :
		vb.forall(vb.remove)

	def create_tree(self, list) :
		treeview = gtk.TreeView(list)
		treeview.set_rules_hint(True)
		treeview.get_selection().set_mode(gtk.SELECTION_SINGLE)

		return treeview

	def create_list_task(self, list) :
		model = gtk.ListStore(
			gobject.TYPE_INT,	#id
			gobject.TYPE_STRING,	#text
			gobject.TYPE_STRING,	#text version of due
			gobject.TYPE_BOOLEAN,	#complete
			gobject.TYPE_BOOLEAN	#editable
		)

		model.set_sort_column_id(TCOLUMN_DUE_, gtk.SORT_ASCENDING)

		for item in list :
			iter = model.append()
			(id, text, due, complete) = item
			model.set(iter,
				TCOLUMN_ID, id,
				TCOLUMN_TEXT, text,
				TCOLUMN_DUE_, time.strftime('%H:%M', time.localtime(due)),
				TCOLUMN_COMPLETE, complete,
				TCOLUMN_EDITABLE, True
			)

		return model

	def create_list_sched(self, list) :
		model = gtk.ListStore(
			gobject.TYPE_INT,	#id
			gobject.TYPE_STRING,	#text
			gobject.TYPE_STRING,	#text version of time
			gobject.TYPE_STRING,	#text version of duration
			gobject.TYPE_BOOLEAN,	#complete
			gobject.TYPE_INT,	#task
			gobject.TYPE_BOOLEAN	#editable
		)

		model.set_sort_column_id(SCOLUMN_TS_, gtk.SORT_ASCENDING)

		for item in list :
			iter = model.append()
			(id, text, ts, duration, complete, task) = item
			model.set(iter,
				SCOLUMN_ID, id,
				SCOLUMN_TEXT, text,
				SCOLUMN_TS_, time.strftime('%H:%M', time.localtime(ts)),
				SCOLUMN_DURATION_, pb.sec2dur(duration),
				SCOLUMN_COMPLETE, bool(complete),
				SCOLUMN_TASK, task,
				SCOLUMN_EDITABLE, True
			)

		return model

	'''Create List Set
	'''
	def create_list_set(self) :
		model = gtk.ListStore(
			gobject.TYPE_STRING,
			gobject.TYPE_STRING,
			gobject.TYPE_BOOLEAN
		)

		iter = model.append()
		model.set(iter, COLUMN_TIME, str(random.randint(0,23)) + ':' + str(random.randint(10,59)), COLUMN_DESC, "stuff",  COLUMN_EDITABLE, True)

		return model

	def add_columns(self, treeview, colset, col_e):
		model = treeview.get_model()

		for col in colset :
			(cid, ctext) = col
			renderer = None
			isbool = model.get_column_type(cid) == gobject.TYPE_BOOLEAN
			if isbool :
				renderer = gtk.CellRendererToggle()
				renderer.connect("toggled", self.on_item_toggled, model)
			else :
				renderer = gtk.CellRendererText()
				renderer.connect("edited", self.on_cell_edited, model)

			renderer.set_property("xalign", 0.0)
			renderer.set_data("column", cid)

			if isbool :
				column = gtk.TreeViewColumn(ctext, renderer, active=cid, activatable=col_e)
			else :
				column = gtk.TreeViewColumn(ctext, renderer, text=cid, editable=col_e)
			treeview.append_column(column)
	def on_item_toggled(self, cell, path_string, model) :
		column = cell.get_data('column')
		iter = model.get_iter_from_string(path_string)
		toggle_item = model.get_value(iter, column)

		toggle_item = not toggle_item

		model.set(iter, column, toggle_item)

	def on_cell_edited(self, cell, path_string, new_text, model) :
		iter = model.get_iter_from_string(path_string)
		path = model.get_path(iter)[0]
		column = cell.get_data("column")

		update = None
		if column == COLUMN_DESC :
			update = new_text
			# call into storage backend here
		elif column == COLUMN_TIME :
			if (pv.check_time(new_text)) :
				update = new_text
				# call into storage backend here
		if update == None :
			self.dialog('Incorrect formatting.')
		else :
			model.set(iter, column, update)


class BackgroundTimer(threading.Thread) :
	def __init__(self) :
		self.callbacks = {'d':[], 'h':[], 'm':[], 's':[]}
		threading.Thread.__init__(self)

	def run(self) :
		global cont

		self.gmt = time.gmtime()
		self.day = time.strftime('%j', self.gmt)
		self.hour = time.strftime('%H', self.gmt)
		self.min = time.strftime('%M', self.gmt)
		self.sec = time.strftime('%S', self.gmt)

		while cont :
			gmt = time.gmtime()
			_day = time.strftime('%j', gmt)
			_hour = time.strftime('%H', gmt)
			_min = time.strftime('%M', gmt)
			_sec = time.strftime('%S', gmt)

			if self.day != _day :
				for c in self.callbacks['d'] :
					c()
			if self.hour != _hour :
				for c in self.callbacks['h'] :
					c()
			if self.min != _min :
				for c in self.callbacks['m'] :
					c()
			if self.sec != _sec :
				for c in self.callbacks['s'] :
					c()
			self.day = _day
			self.hour = _hour
			self.min = _min
			self.sec = _sec

			time.sleep(0.5)

	def add_callback(self, period, callback) :
		self.callbacks[period].append(callback)

def gtkm() :
	global cont
	while cont :
		while gtk.events_pending() :
			gtk.main_iteration()
		time.sleep(0.02)

if __name__ == '__main__':
	psyched = Psyched()
	try:
		gtkm()
	except KeyboardInterrupt:
		cont = False
